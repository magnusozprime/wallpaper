<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAGNUS PRIME - Live Wallpaper</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0044;
            font-family: 'Courier New', Courier, monospace;
            font-size: 16px;
            letter-spacing: 2px;
            pointer-events: none;
            transition: opacity 0.5s;
            text-shadow: 0 0 10px #ff0044;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="loading">SYSTEM INITIALIZING...</div>

    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { LineSegments2 } from 'three/addons/lines/LineSegments2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineSegmentsGeometry } from 'three/addons/lines/LineSegmentsGeometry.js';

        // --- CONFIG ---
        const TEXT_STR = "MAGNUS PRIME";
        const DROP_START_Y = 25; 
        const GRAVITY = 0.45;     
        const LINE_COLOR = 0xff0044; // Laser Red
        const LINE_THICKNESS = 4;
        const RESET_TIME_MS = 30000; // Restart animation every 30 seconds

        // --- SCENE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020202);
        // Exponential fog creates the "floor" without needing geometry
        scene.fog = new THREE.FogExp2(0x020202, 0.03);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 50); 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- PARTICLE SYSTEM ---
        const particles = [];
        const smokeTex = createSmokeTexture();
        
        function createSmokeTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255, 0, 50, 0.5)'); 
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        const smokeMaterial = new THREE.SpriteMaterial({ 
            map: smokeTex, transparent: true, opacity: 0.8, color: 0xff0044, 
            blending: THREE.AdditiveBlending, depthWrite: false 
        });

        function spawnImpact(x, z) {
            // Ring Shockwave
            const ringGeo = new THREE.RingGeometry(0.5, 1.2, 32);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xff0044, side: THREE.DoubleSide, transparent: true });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = -Math.PI / 2;
            ring.position.set(x, 0.1, z);
            scene.add(ring);
            particles.push({ type: 'ring', mesh: ring, scale: 1, opacity: 1 });

            // Spike
            const spikeGeo = new THREE.CylinderGeometry(0.2, 0, 15, 8);
            const spikeMat = new THREE.MeshBasicMaterial({ color: 0xffaaaa, transparent: true, opacity: 0.8 });
            const spike = new THREE.Mesh(spikeGeo, spikeMat);
            spike.position.set(x, 7.5, z);
            scene.add(spike);
            particles.push({ type: 'spike', mesh: spike, life: 1.0 });

            // Smoke
            for(let i=0; i<15; i++) {
                const sprite = new THREE.Sprite(smokeMaterial);
                sprite.position.set(x + (Math.random()-0.5)*3, 0.5, z + (Math.random()-0.5)*3);
                const s = Math.random() * 4 + 2;
                sprite.scale.set(s, s, 1);
                scene.add(sprite);
                particles.push({
                    type: 'smoke', mesh: sprite,
                    velY: Math.random() * 0.2 + 0.1,
                    velX: (Math.random() - 0.5) * 0.3,
                    velZ: (Math.random() - 0.5) * 0.3,
                    life: 1.5
                });
            }
        }

        // --- STATE ---
        let letters = []; 
        let activeIndex = 0;
        let phase = 'loading'; 
        let dropVelocity = 0;
        let shakeIntensity = 0;
        let loopTimer = null;
        
        // Drone variables
        let droneTarget = new THREE.Vector3(0, 15, 40);
        let lastDroneUpdate = 0;

        // --- FONT & REFLECTION LOGIC ---
        const loader = new FontLoader();
        loader.load('https://unpkg.com/three@0.160.0/examples/fonts/droid/droid_sans_bold.typeface.json', function (font) {
            document.getElementById('loading').style.opacity = 0;
            
            const size = 3;
            let offset = 0;
            
            // Build geometry
            for(let char of TEXT_STR) {
                if(char === ' ') { offset += size; continue; }
                
                const geo = new TextGeometry(char, { font: font, size: size, height: 0, curveSegments: 6 });
                geo.computeBoundingBox();
                const w = geo.boundingBox.max.x - geo.boundingBox.min.x;
                geo.translate(-w/2, 0, 0); 

                const edges = new THREE.EdgesGeometry(geo);
                const lineGeo = new LineSegmentsGeometry();
                lineGeo.fromEdgesGeometry(edges);

                // MAIN LETTER
                const mat = new LineMaterial({ color: LINE_COLOR, linewidth: LINE_THICKNESS });
                mat.resolution.set(window.innerWidth, window.innerHeight);
                const mesh = new LineSegments2(lineGeo, mat);

                // REFLECTION LETTER (Mirror)
                const refMat = new LineMaterial({ color: LINE_COLOR, linewidth: LINE_THICKNESS, transparent: true, opacity: 0.15 });
                refMat.resolution.set(window.innerWidth, window.innerHeight);
                const refMesh = new LineSegments2(lineGeo, refMat);
                refMesh.scale.y = -1; // Flip upside down
                
                // Store data
                const letterObj = {
                    main: mesh,
                    ref: refMesh,
                    finalX: offset + w/2,
                    mats: [mat, refMat]
                };

                scene.add(mesh);
                scene.add(refMesh);
                letters.push(letterObj);
                
                // Initial State
                mesh.visible = false;
                refMesh.visible = false;
                
                offset += w + 0.8; 
            }

            // Center everything
            const startX = -offset / 2;
            letters.forEach(l => {
                l.finalX += startX;
                // Set start positions
                l.main.position.set(l.finalX, DROP_START_Y, 0);
                l.ref.position.set(l.finalX, -DROP_START_Y, 0); // Mirror pos
            });

            // Start Animation
            startSequence();
            animate();
        });

        function startSequence() {
            phase = 'drop';
            activeIndex = 0;
            dropVelocity = 0;
            camera.position.set(0, 10, 50);
            
            // Hide all
            letters.forEach(l => { l.main.visible = false; l.ref.visible = false; });
            
            // Show first
            if(letters.length > 0) {
                letters[0].main.visible = true;
                letters[0].ref.visible = true;
                letters[0].main.position.y = DROP_START_Y;
                letters[0].ref.position.y = -DROP_START_Y;
            }
            
            // Reset Loop Timer
            loopTimer = Date.now();
        }

        function updateDroneTarget() {
            const angle = Math.random() * Math.PI * 2;
            const radius = 30 + Math.random() * 20; 
            const height = 10 + Math.random() * 20;
            droneTarget.set(Math.sin(angle) * radius, height, Math.cos(angle) * radius);
        }

        function animate() {
            requestAnimationFrame(animate);
            const now = Date.now();

            if (phase === 'drop') {
                const item = letters[activeIndex];
                dropVelocity += GRAVITY;
                
                // Move Main
                item.main.position.y -= dropVelocity;
                // Move Reflection (Inverse)
                item.ref.position.y = -item.main.position.y; // Simplified reflection math for y=0 plane

                // Collision
                if (item.main.position.y <= 0) {
                    item.main.position.y = 0;
                    item.ref.position.y = 0;
                    
                    spawnImpact(item.main.position.x, 0);
                    shakeIntensity = 2.0; 
                    
                    // Disappear
                    item.main.visible = false;
                    item.ref.visible = false;

                    activeIndex++;
                    if (activeIndex < letters.length) {
                        phase = 'interval';
                        setTimeout(() => {
                            dropVelocity = 0;
                            const next = letters[activeIndex];
                            next.main.position.y = DROP_START_Y;
                            next.ref.position.y = -DROP_START_Y;
                            next.main.visible = true;
                            next.ref.visible = true;
                            phase = 'drop';
                        }, 100); 
                    } else {
                        // Finale
                        phase = 'finale';
                        updateDroneTarget();
                        setTimeout(() => {
                           letters.forEach(l => {
                               l.main.position.y = 0; l.ref.position.y = 0;
                               l.main.visible = true; l.ref.visible = true;
                           }); 
                        }, 500);
                    }
                }
            }
            else if (phase === 'finale') {
                // Drone Movement
                if (now - lastDroneUpdate > 4000) {
                    updateDroneTarget();
                    lastDroneUpdate = now;
                }
                camera.position.lerp(droneTarget, 0.01);
                camera.lookAt(0, 4, 0);

                // RESTART LOOP Logic
                if (now - loopTimer > RESET_TIME_MS) {
                    startSequence();
                }
            }
            else if (phase === 'interval') {
                 camera.position.lerp(new THREE.Vector3(0, 10, 50), 0.1);
                 camera.lookAt(0, 5, 0);
            }

            // Camera Shake
            if(shakeIntensity > 0) {
                const s = shakeIntensity * 0.5;
                camera.position.x += (Math.random() - 0.5) * s;
                camera.position.y += (Math.random() - 0.5) * s;
                shakeIntensity *= 0.9; 
            }

            // Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                if (p.type === 'ring') {
                    p.scale += 2.0;
                    p.opacity -= 0.04;
                    p.mesh.scale.set(p.scale, p.scale, 1);
                    p.mesh.material.opacity = p.opacity;
                    if (p.opacity <= 0) removeParticle(i);
                } 
                else if (p.type === 'spike') {
                    p.mesh.scale.y -= 0.05;
                    p.life -= 0.05;
                    if(p.life <= 0) removeParticle(i);
                }
                else if (p.type === 'smoke') {
                    p.mesh.position.add(new THREE.Vector3(p.velX, p.velY, p.velZ));
                    p.life -= 0.015;
                    p.mesh.material.opacity = p.life;
                    if (p.life <= 0) removeParticle(i);
                }
            }

            renderer.render(scene, camera);
        }

        function removeParticle(index) {
            scene.remove(particles[index].mesh);
            particles.splice(index, 1);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            letters.forEach(l => {
                l.mats.forEach(m => m.resolution.set(window.innerWidth, window.innerHeight));
            });
        });

    </script>
</body>
</html>
